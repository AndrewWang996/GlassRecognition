package com.opencv.tilen.facedetectionandrecognition_urvrv;

import android.app.Activity;
import android.graphics.Bitmap;
import android.hardware.Camera;
import android.os.Bundle;
import android.util.DisplayMetrics;
import android.view.Menu;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.MotionEvent;
import android.view.SubMenu;
import android.view.SurfaceView;
import android.view.View;
import android.view.WindowManager;
import android.widget.ImageView;

import com.google.android.glass.widget.CardScrollView;

import org.opencv.android.BaseLoaderCallback;
import org.opencv.android.CameraBridgeViewBase;
import org.opencv.android.LoaderCallbackInterface;
import org.opencv.android.OpenCVLoader;
import org.opencv.core.Mat;

import java.io.IOException;
import java.util.List;

/**
 * An {@link Activity} showing a tuggable "Hello World!" card.
 * <p/>
 * The main content view is composed of a one-card {@link CardScrollView} that provides tugging
 * feedback to the user when swipe gestures are detected.
 * If your Glassware intends to intercept swipe gestures, you should set the content view directly
 * and use a {@link com.google.android.glass.touchpad.GestureDetector}.
 *
 * @see <a href="https://developers.google.com/glass/develop/gdk/touch">GDK Developer Guide</a>
 */
public class MainActivity extends Activity implements CameraBridgeViewBase.CvCameraViewListener2, Gestures.OnGesturesCallback {

    /**
     * {@link CardScrollView} to use as the main content view.
     */
    private CardScrollView mCardScroller;

    /**
     * "Hello World!" {@link View} generated by .
     */
    private MyJavaCameraView mOpenCvCameraView;
    private FaceDetection faceDetection;
    private ImageView ivPicture;
    private Gestures mGestureDetector;
    private boolean isCameraUsed = true;
    private LocalPicturesDetection localPictures;
    private List<Camera.Size> cameraResolutions;
    private boolean isSubmenuAdded;

    private BaseLoaderCallback mLoaderCallback = new BaseLoaderCallback(this) {
        @Override
        public void onManagerConnected(int status) {
            switch (status) {
                case LoaderCallbackInterface.SUCCESS: {
                    Global.InfoDebug("MainActivity.mLoaderCallback.onManagerConnected:OpenCV loaded successfully");
                    faceDetection = new FaceDetection(mAppContext);
                    mOpenCvCameraView.enableView();

                   /* Mat mMat = null;
                    try {
                        mMat = Utils.loadResource(mAppContext, R.drawable.lena);
                    } catch (IOException e) {
                        e.printStackTrace(); */
                }

                break;
                default: {
                    super.onManagerConnected(status);
                }
                break;
            }
        }
    };


    @Override
    protected void onCreate(Bundle bundle) {
        super.onCreate(bundle);
        setContentView(R.layout.activity_main);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
        mGestureDetector = new Gestures(this, this);
        mOpenCvCameraView = (MyJavaCameraView) findViewById(R.id.tutorial1_activity_java_surface_view);
        mOpenCvCameraView.setVisibility(SurfaceView.VISIBLE);
        mOpenCvCameraView.setCvCameraViewListener(this);
        ivPicture = (ImageView) findViewById(R.id.ivPicture);
        isSubmenuAdded = false;
       /* Bitmap bitmap = BitmapFactory.decodeResource(this.getResources(),
                R.drawable.lena);
        ivPicture.setImageBitmap(bitmap);*/

    }

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu, menu);
        return true;
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // This is called right before the menu is shown, every time it is shown.
            if(isSubmenuAdded == false) {
                SubMenu submenu = menu.addSubMenu(0, -1, 1, getString(R.string.resolutions));
                int index = 0;
                String textToDisplay;
                for(Camera.Size resolution : cameraResolutions)
                {
                        textToDisplay = resolution.width + " x " + resolution.height;
                        submenu.add(0, index, Menu.NONE, textToDisplay);
                        index++;
                }
                isSubmenuAdded = true;
            }

        return true;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Handle item selection. Menu items typically start another
        // activity, start a service, or broadcast another intent.
        Global.LogDebug("MainActivity.onOptionsItemSelected(): item name: " + item.getTitle() + " item id: " + item.getItemId());
        switch (item.getItemId()) {
            case R.id.itemCamera:
                Global.LogDebug("MainActivity.onOptionsItemSelected(): R.id.itemCamera");
                isCameraUsed = true;
                return true;
            case R.id.itemImage:
                Global.LogDebug("MainActivity.onOptionsItemSelected(): R.id.itemImage");
                isCameraUsed = false;
                return true;
            default:
                if(item.getItemId() == -1) // submenu
                {
                    return super.onOptionsItemSelected(item);
                }
                else
                {
                    // we need to enable CameraView (and show it) hide ImageView to use Camera
                    showCameraView();
                    isCameraUsed = true;
                    mOpenCvCameraView.setResolution(cameraResolutions.get(item.getItemId()));
                    return true;
                }
        }
    }

    @Override
    public void onOptionsMenuClosed(Menu menu) { // called when you select an Item Menu or just cancel Menu
        Global.LogDebug("MainActivity.onOptionsMenuClosed");
        if (isCameraUsed) {
          showCameraView();
        }
        else {
            manipulateStaticImage();
        }
        super.onOptionsMenuClosed(menu);
    }

    @Override
    protected void onResume() {
        super.onResume();
        Global.InfoDebug("MainActivity.onResume()");
        // mCardScroller.activate();
        OpenCVLoader.initAsync(OpenCVLoader.OPENCV_VERSION_2_4_11, this, mLoaderCallback);
    }

    @Override
    protected void onPause() {
        super.onPause();
        //mCardScroller.deactivate();
        if (mOpenCvCameraView != null)
            mOpenCvCameraView.disableView();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
        if (mOpenCvCameraView != null)
            mOpenCvCameraView.disableView();
    }

    @Override
    public void onCameraViewStarted(int width, int height) {

    }

    @Override
    public void onCameraViewStopped() {

    }

    @Override
    public Mat onCameraFrame(CameraBridgeViewBase.CvCameraViewFrame inputFrame) { // needs  Bitmap type: 640*360 (so the same size as camera)

        //Mat outputFDPicture = faceDetection.getFaceDetectionPicture(inputFrame.rgba());
        //Mat result = new Mat();
        //Imgproc.cvtColor(outputFDPicture, result, Imgproc.COLOR_RGB2BGR555);
        /*                    Mat mMat = null;

        try {
            mMat = Utils.loadResource(this, R.drawable.lena);
        } catch (IOException e) {
            e.printStackTrace();
        }
        Mat result = new Mat();
        Global.TestDebug("test : " +mMat.cols());
        Imgproc.cvtColor(mMat, result, Imgproc.COLOR_RGB2BGRA);
        Bitmap bmp = Bitmap.createBitmap(mMat.cols(), mMat.rows(), Bitmap.Config.ARGB_8888);
        Utils.matToBitmap(mMat, bmp);
        Mat outMat = new Mat();
        */
        return inputFrame.rgba();
    }

    @Override
    public boolean onGenericMotionEvent(MotionEvent event) {
        if (mGestureDetector != null) {
            return mGestureDetector.onMotionEvent(event);
        }
        return false;
    }

    @Override
    public void onTwoTap() {
        // mOpenCvCameraView needs to be enabled and we can not do this in onManagerConnected (mCamera is null)
        if(cameraResolutions == null) {
            cameraResolutions = mOpenCvCameraView.getResolutionList();
            removeUnWantedResolutions();
        }
        // beacuse of lag, we disable when navigation on Menu
        mOpenCvCameraView.disableView();
        openOptionsMenu();
    }

    private void manipulateStaticImage() {
        mOpenCvCameraView.setVisibility(View.GONE);
        try {
            localPictures = new LocalPicturesDetection(this, R.drawable.lena);
        } catch (IOException e) {
            Global.ErrorDebug("MainActivity.manipulateStaticImage(): " + e.toString());
        }
        //TODO change
        Mat outputPicture = faceDetection.getFaceDetectionPicture(localPictures.getlocalPicture());
        Global.TestDebug("manipulateStaticImage():" + outputPicture.cols());
        Bitmap bitmap = LocalPicturesDetection.matToBitmap(outputPicture);
        ivPicture.setVisibility(View.VISIBLE);
        ivPicture.setImageBitmap(bitmap);

    }

    //  /* Select the size that fits surface considering maximum size allowed */ - from OpenCV
    // so we ignore size which are higher than screen size (in our case 640 x 360)
    private void removeUnWantedResolutions()
    {
        // screen dimensions
        DisplayMetrics displaymetrics = new DisplayMetrics();
        getWindowManager().getDefaultDisplay().getMetrics(displaymetrics);
        int screenHeight = displaymetrics.heightPixels;
        int screenWidth = displaymetrics.widthPixels;
        for(int i = 0; i < cameraResolutions.size();)
        {
            Camera.Size resolution = cameraResolutions.get(i);
            if(resolution.width <= screenWidth && resolution.height <= screenHeight) {
                i++;
            }
            else
                cameraResolutions.remove(resolution);
        }
    }

    private void showCameraView()
    {
        ivPicture.setVisibility(View.GONE);
        mOpenCvCameraView.setVisibility(View.VISIBLE);
        mOpenCvCameraView.enableView();
    }

}
